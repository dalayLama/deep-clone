Метод deepCopy реализован в классе CloneLib.

Его алгоритм достаточно простой: сначала нам нужно получить информацию о классе объекта и о его полях - этим занимается 
ObjectMetaInfoReader (конкретная реализация DefaultObjectMetaInfoReader). После получения данной информации,
она, вместе с объектом, передаётся в CloneResolver(конкретная реализация CloneResolverManager)

В информации о классе находится условный тип класса: массив, коллекция, 
простой тип (String, Number, примитивы) или сложный тип(какой-то кастомный класс). На основе этого условного типа, 
Resolver, определяет CloneMaker-а, т.е. того, кто будет непосредственно клонировать конкретный объект.

Для каждого условного типа имеется соответсвующий CloneMaker. Если CloneMaker занимается клонированием сложных 
объектов(если у них есть ссылки на другие объекты), то тогда, CloneMaker-у добавляется зависимость Resolver и создание
вложных объектов дилегируется ему.

P.S. Я видел в задании, что в качестве примера использования был статичный метод класса, надеюсь я понял правильно
и это не принципиальный момент.

P.S. в тестах накидал примеров клонирования с разными объектами